#!/bin/bash

function do_remote_command() {
    # Abstraction for doing RPC over SSH
    # Will use a control socket if it exists; however, it will not create it.
    # This script requires a number of environment variables to be set in order for it to function
    # properly. You may test this function like this by using the test string generated by:
    # ./ssh-vpn.sh get-testing-cli
    #
    # You may pass a multiline command like so:
    # do_remote_command bash <<EOF
    # egrep '^my_stuff$' /tmp/test > /dev/null || {
    #     echo 'my_stuff' >> /tmp/test
    # }
    # EOF
    if [ -z "${PRIVATE_KEY_PATH}" ]; then
        ssh -p "${REMOTE_PORT}" -S "${HOME}/.ssh/%C" "${REMOTE_USER}"@"${REMOTE_HOST}" $@
		SSH_EXIT_CODE=$?
    else
        ssh -i "${PRIVATE_KEY_PATH}" -p "${REMOTE_PORT}" -S "${HOME}/.ssh/%C" "${REMOTE_USER}"@"${REMOTE_HOST}" $@
		SSH_EXIT_CODE=$?
    fi
	return ${SSH_EXIT_CODE}
}

function copy_file_to_remote(){
    # Abstraction for copying a file over SSH
    # ARGS: $1 = local file path
    #       $2 = remote path
	# Will use a control socket if it exists; however, it will not create it.
    # This script requires REMOTE_USER, REMOTE_HOST, AND REMOTE_PORT to be defined in the
    # environment. Optionally, PRIVATE_KEY_PATH may be defined.
    # You may test this function like this:
    # REMOTE_HOST="1.1.1.1"; REMOTE_PORT="22"; REMOTE_USER="user"; copy_file_to_remote ./myfile
    LOCAL_FILE="$1"
    REMOTE_PATH="$2"
    if [ -z "${PRIVATE_KEY_PATH}" ]; then
        scp -P "${REMOTE_PORT}" -o ControlPath="${HOME}/.ssh/%C" "${LOCAL_FILE}" "${REMOTE_USER}"@"${REMOTE_HOST}:${REMOTE_PATH}"
		SSH_EXIT_CODE=$?
    else
        scp -i "${PRIVATE_KEY_PATH}" -P "${REMOTE_PORT}" -o ControlPath="${HOME}/.ssh/%C" "${LOCAL_FILE}" "${REMOTE_USER}"@"${REMOTE_HOST}:${REMOTE_PATH}"
		SSH_EXIT_CODE=$?
    fi
	return ${SSH_EXIT_CODE}
}

function discover_mtu() {
	# ARGS: $1 = Integer : Maximum PAYLOAD : Example: 1472
	#		$2 = source interface
    #       $3 = target address
	#
	# Assuming a customary MTU of 1500 bytes, the maximum payload would caluculate as follows:
	# 1500 - IP encapsulation (20) - ICMP encapsulation (8) = 1472
	#
	# Therefore, if we can transmit a 1472 byte payload without fragmentation, but not a 1473 byte
	# payload, then the MTU is 1500 bytes.

	ICMP_ENCAP=8
	IP_ENCAP=20

	HIGH=$1
	SOURCE_IFACE=$2
    TARGET_ADDRESS=$3
	PAYLOAD="${HIGH}"
	LOW=1
	LAST_SUCCESS=0

	set +e
	until [ ${LOW} -gt ${HIGH} ]; do

		ping -I "${SOURCE_IFACE}" -c 1 -W 500 -M do -s "${PAYLOAD}" "${TARGET_ADDRESS}" > /dev/null 2>&1
		if [ $? -eq 0 ]; then
			LAST_SUCCESS=${PAYLOAD}
			LOW=$(($PAYLOAD + 1))
		else
			HIGH=$(($PAYLOAD - 1))
		fi

		PAYLOAD=$((($HIGH + $LOW) / 2))

	done
	set -e

	echo $(($LAST_SUCCESS + $ICMP_ENCAP + $IP_ENCAP))
	if [ ${LAST_SUCCESS} -eq 0 ]; then
		return 1
	fi
	return 0
}

function get_default_route(){
    # RETURNS: the FIRST default route from "ip route" or null.
    ip route | egrep -m 1 '^default'
}

function get_metric(){
    # Takes as input a string matching a line of output from "ip route".
    # RETRUNS: the metric of the specified route string or null.
    echo "$@" | awk '{for (i=1; i<NF; i++) {if ($i == "metric") {print $(i+1);exit;}}}'
}

function get_egress_interface(){
    # Takes as input a string matching a line of output from "ip route".
    # RETURNS: the egress interface for that route.
    echo "$@" | awk '{for (i=1; i<NF; i++) {if ($i == "dev") {print $(i+1);exit;}}}'
}

function get_nexthop(){
    # Takes as input a string matching a line of output from "ip route".
    # RETURNS: the egress interface for that route.
    echo "$@" | awk '{for (i=1; i<NF; i++) {if ($i == "via") {print $(i+1);exit;}}}'
}

function get_route(){
    # ARGS: $1 = IP address.
    # RETURNS: ip route command line arguments for the route for the specified IP or subnet
    # Can error if no route in routing table
    ip route get "$1" | head -n1
}

function increment_metric_if_minimum(){
    # Takes as input a string matching a line of output from "ip route".
    # Makes the metric of the specified route == 1 if the metric doesn't exist or is 0.
    METRIC="$(get_metric $@)"
    if [ -z "${METRIC}" ] || [ "${METRIC}" == "0" ]; then
        ip route add $@ metric 1
        ip route delete $@
    fi
}

function get_remote_default_egress_interface(){
    # RETURNS: the egress interface for the first default route listed in "ip route" on the remote.
    do_remote_command ip route | \
        egrep -m 1 '^default' | \
        awk '{for (i=1; i<NF; i++) {if ($i == "dev") {print $(i+1);exit;}}}'
}

function get_local_default_egress_interface(){
    # RETURNS: the egress interface for the first default route listed in "ip route" on local.
    ip route | \
        egrep -m 1 '^default' | \
        awk '{for (i=1; i<NF; i++) {if ($i == "dev") {print $(i+1);exit;}}}'
}

function get_remote_masquerade_rule(){
    # ARGS: $1 = SOURCE_FOR_PAT: the source host address or network address that is part of the
    #            masquerade rule.
    #       $2 = MASQ_EGRESS_INTERFACE: the interface on the remote from which PAT traffic will exit.
    # RETURNS: the PAT (masquerade) iptables rule number
    SOURCE_FOR_PAT="$1"
    MASQ_EGRESS_INTERFACE="$2"
    do_remote_command iptables -t nat -L POSTROUTING -v -n --line-numbers | \
        awk '
            # We are only interested in PAT rules
            ($4 == "MASQUERADE"){
                # We will match on the egress interface and the source address
                if($8 == "'"${MASQ_EGRESS_INTERFACE}"'" && $9 == "'"${SOURCE_FOR_PAT}"'") {
                    # The first column is the rule number
                    print $1;
                }
            }'
}

function get_local_masquerade_rule(){
    # ARGS: $1 = SOURCE_FOR_PAT: the source host address or network address that is part of the
    #            masquerade rule.
    #       $2 = MASQ_EGRESS_INTERFACE: the interface on the local from which PAT traffic will exit.
    # RETURNS: the PAT (masquerade) iptables rule number
    SOURCE_FOR_PAT="$1"
    MASQ_EGRESS_INTERFACE="$2"
    iptables -t nat -L POSTROUTING -v -n --line-numbers | \
        awk '
            # We are only interested in PAT rules
            ($4 == "MASQUERADE"){
                # We will match on the egress interface and the source address
                if($8 == "'"${MASQ_EGRESS_INTERFACE}"'" && $9 == "'"${SOURCE_FOR_PAT}"'") {
                    # The first column is the rule number
                    print $1;
                }
            }'
}

function enable_remote_masquerade(){
    # Enables remote masquerade for this and only this source address and egress interface
    # combination.
    # ARGS: $1 = SOURCE_FOR_PAT: the source host address or network address that is part of the
    #            masquerade rule.
    #       $2 = MASQ_EGRESS_INTERFACE: the interface on the remote from which PAT traffic will exit.
    SOURCE_FOR_PAT="$1"
    MASQ_EGRESS_INTERFACE="$2"
    MASQ_RULE_NUMBER="$(get_remote_masquerade_rule ${SOURCE_FOR_PAT} ${MASQ_EGRESS_INTERFACE})"
    if [ -z "${MASQ_RULE_NUMBER}" ]; then
        do_remote_command iptables -t nat -A POSTROUTING -s "${SOURCE_FOR_PAT}" -o "${MASQ_EGRESS_INTERFACE}" -j MASQUERADE
    fi
}

function enable_local_masquerade(){
    # Enables local masquerade for this and only this source address and egress interface
    # combination.
    # ARGS: $1 = SOURCE_FOR_PAT: the source host address or network address that is part of the
    #            masquerade rule.
    #       $2 = MASQ_EGRESS_INTERFACE: the interface on the local from which PAT traffic will exit.
    SOURCE_FOR_PAT="$1"
    MASQ_EGRESS_INTERFACE="$2"
    MASQ_RULE_NUMBER="$(get_local_masquerade_rule ${SOURCE_FOR_PAT} ${MASQ_EGRESS_INTERFACE})"
    if [ -z "${MASQ_RULE_NUMBER}" ]; then
        iptables -t nat -A POSTROUTING -s "${SOURCE_FOR_PAT}" -o "${MASQ_EGRESS_INTERFACE}" -j MASQUERADE
    fi
}

function disable_remote_masquerade(){
    # Disables remote masquerade for this and only this source address and egress interface
    # combination.
    # ARGS: $1 = SOURCE_FOR_PAT: the source host address or network address that is part of the
    #            masquerade rule.
    #       $2 = MASQ_EGRESS_INTERFACE: the interface on the remote from which PAT traffic will exit.
    SOURCE_FOR_PAT="$1"
    MASQ_EGRESS_INTERFACE="$2"
    MASQ_RULE_NUMBER="$(get_remote_masquerade_rule ${SOURCE_FOR_PAT} ${MASQ_EGRESS_INTERFACE})"
    if [ ! -z "${MASQ_RULE_NUMBER}" ]; then
        do_remote_command iptables -t nat -D POSTROUTING "${MASQ_RULE_NUMBER}"
    fi
}

function disable_local_masquerade(){
    # Disables local masquerade for this and only this source address and egress interface
    # combination.
    # ARGS: $1 = SOURCE_FOR_PAT: the source host address or network address that is part of the
    #            masquerade rule.
    #       $2 = MASQ_EGRESS_INTERFACE: the interface on the local from which PAT traffic will exit.
    SOURCE_FOR_PAT="$1"
    MASQ_EGRESS_INTERFACE="$2"
    MASQ_RULE_NUMBER="$(get_local_masquerade_rule ${SOURCE_FOR_PAT} ${MASQ_EGRESS_INTERFACE})"
    if [ ! -z "${MASQ_RULE_NUMBER}" ]; then
        iptables -t nat -D POSTROUTING "${MASQ_RULE_NUMBER}"
    fi
}

# function get_remote_client_ip4(){
#     # RETURNS: IPv4 address for a remote client for this process or null.
#     awk '
#         # Filter out the first record, NF==1. It is the header.
#         (NF>1){
#             # 01 is an active connection versus some other state
#             if($4 == 01){
#                 ip4 = sprintf("%d.%d.%d.%d", \
#                     strtonum("0x" substr($3,7,2)), \
#                     strtonum("0x" substr($3,5,2)), \
#                     strtonum("0x" substr($3,3,2)), \
#                     strtonum("0x" substr($3,0,2)));
#                     # Some active connections are localhost. We are not interested in those.
#                     if(ip4 != "127.0.0.1") {print ip4;}
#             }
#         }
#     ' /proc/$PPID/net/tcp
# }

# function get_subnet(){
#     # RETURNS: IPv4 address for a remote client for this process or null.
#     awk '
#         # Filter out the first record, NF==1. It is the header.
#         (NF>1){
#             # 01 is an active connection versus some other state
#             if($4 == 01){
#                 ip4 = sprintf("%d.%d.%d.%d", \
#                     strtonum("0x" substr($3,7,2)), \
#                     strtonum("0x" substr($3,5,2)), \
#                     strtonum("0x" substr($3,3,2)), \
#                     strtonum("0x" substr($3,0,2)));
#                     # Some active connections are localhost. We are not interested in those.
#                     if(ip4 != "127.0.0.1") {print ip4;}
#             }
#         }
#     ' /proc/net/route
# }

# TODO: these do not function properly
# 1) the RPC does not work (the question mark does not get expanded on the remote)
# 2) hostapd is RFKILL aware. The service does not stop when soft killed. It simply waits for the
#    softkill to be removed. I suspect other services might do something similar. If we really want
#    to know we have exclusive access to the WiFi hardware, there's probably more research
#    necessary. However, for the namesake of these functions, they may still be valuable if
#    implemented as is.
# function disable_remote_wifi_interface() {
#     # Disables remote wifi interface
#     # combination.
#     # ARGS: $1 = INTERFACE_NAME: the name of the wireless interface to disable.
#     INTERFACE_NAME="$1"
#     do_remote_command bash echo 1 '>' /sys/class/net/"${INTERFACE_NAME}"/phy80211/rfkill\?/soft
# }

# function enable_remote_wifi_interface() {
#     # Enables remote wifi interface
#     # combination.
#     # ARGS: $1 = INTERFACE_NAME: the name of the wireless interface to disable.
#     INTERFACE_NAME="$1"
#     do_remote_command bash -c 'echo 0 > /sys/class/net/'"${INTERFACE_NAME}"'/phy80211/rfkill?/soft'
# }

function get_nameserver_addresses(){
    awk '/^nameserver/ { print $2 }' /etc/resolv.conf
}

# Firewall functions
function disable_remote_iptables(){
    do_remote_command 'iptables-save > /etc/iptables.ssh-vpn.sh.backup'
    do_remote_command 'iptables -F'
    do_remote_command 'iptables -P INPUT ACCEPT'
    do_remote_command 'iptables -P OUTPUT ACCEPT'
    do_remote_command 'iptables -P FORWARD ACCEPT'
}

function disable_local_iptables(){
    iptables-save > /etc/iptables.ssh-vpn.sh.backup
    iptables -F
    iptables -P INPUT ACCEPT
    iptables -P OUTPUT ACCEPT
    iptables -P FORWARD ACCEPT
}

function enable_local_iptables(){
    iptables-restore < /etc/iptables.ssh-vpn.sh.backup
    if [ $? -eq 0 ]; then
        rm -f /etc/iptables.ssh-vpn.sh.backup
    fi
}


